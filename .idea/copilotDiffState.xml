<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/Service/AtividadeService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/Service/AtividadeService.kt" />
              <option name="originalContent" value="package com.example.oportunyfam.Service&#10;&#10;import com.example.oportunyfam.model.AtividadeRequest&#10;import com.example.oportunyfam.model.AtividadeResponse&#10;import com.example.oportunyfam.model.AulaRequest&#10;import com.example.oportunyfam.model.AulaResponse&#10;import retrofit2.Call&#10;import retrofit2.http.*&#10;&#10;interface AtividadeService {&#10;&#10;    // --- ROTAS DE ATIVIDADE (CRUD) ---&#10;&#10;    // POST /v1/atividades/&#10;    @Headers(&quot;Content-Type: application/json&quot;)&#10;    @POST(&quot;atividades&quot;)&#10;    fun criarAtividade(@Body atividade: AtividadeRequest): Call&lt;AtividadeResponse&gt;&#10;&#10;    // PUT /v1/atividades/:id&#10;    @Headers(&quot;Content-Type: application/json&quot;)&#10;    @PUT(&quot;atividades/{id}&quot;)&#10;    fun atualizarAtividade(@Path(&quot;id&quot;) id: Int, @Body atividade: AtividadeRequest): Call&lt;AtividadeResponse&gt;&#10;&#10;    // DELETE /v1/atividades/:id&#10;    @DELETE(&quot;atividades/{id}&quot;)&#10;    fun deletarAtividade(@Path(&quot;id&quot;) id: Int): Call&lt;Unit&gt;&#10;&#10;    // GET /v1/atividades/ (Busca todas, possivelmente com filtros)&#10;    @GET(&quot;atividades&quot;)&#10;    fun buscarTodasAtividades(): Call&lt;List&lt;AtividadeResponse&gt;&gt; // Retorna detalhes da View&#10;&#10;    // GET /v1/atividades/:id (Busca por ID)&#10;    @GET(&quot;atividades/{id}&quot;)&#10;    fun buscarAtividadePorId(@Path(&quot;id&quot;) id: Int): Call&lt;AtividadeResponse&gt;&#10;&#10;    // --- ROTAS DE AULAS (CRUD) ---&#10;    // Nota: O prefixo &quot;/aulas&quot; é adicionado à URL base do Retrofit, se a rota for absoluta.&#10;    // Se a rota for relativa (como aqui), ela é concatenada com o prefixo do controller.&#10;&#10;    // POST /v1/atividades/aulas/&#10;    @POST(&quot;atividades/aulas&quot;)&#10;    fun criarAula(@Body aula: AulaRequest): Call&lt;AulaResponse&gt;&#10;&#10;    // PUT /v1/atividades/aulas/:id&#10;    @PUT(&quot;atividades/aulas/{id}&quot;)&#10;    fun atualizarAula(@Path(&quot;id&quot;) id: Int, @Body aula: AulaRequest): Call&lt;AulaResponse&gt;&#10;&#10;    // DELETE /v1/atividades/aulas/:id&#10;    @DELETE(&quot;atividades/aulas/{id}&quot;)&#10;    fun deletarAula(@Path(&quot;id&quot;) id: Int): Call&lt;Unit&gt;&#10;&#10;    // GET /v1/atividades/aulas/:id (Buscar aula específica)&#10;    @GET(&quot;atividades/aulas/{id}&quot;)&#10;    fun buscarAulaPorId(@Path(&quot;id&quot;) id: Int): Call&lt;AulaResponse&gt; // Usamos AulaResponse aqui, não o HorarioDetalhe&#10;&#10;    // GET /v1/atividades/aulas (Buscar todas as aulas)&#10;    @GET(&quot;atividades/aulas&quot;)&#10;    fun buscarTodasAulas(): Call&lt;List&lt;AulaResponse&gt;&gt;&#10;&#10;    // GET /v1/atividades/aulas/instituicao/:idInstituicao (Buscar aulas por Instituição)&#10;    @GET(&quot;atividades/aulas/instituicao/{idInstituicao}&quot;)&#10;    fun buscarAulasPorInstituicao(@Path(&quot;idInstituicao&quot;) idInstituicao: Int): Call&lt;List&lt;AulaResponse&gt;&gt;&#10;}" />
              <option name="updatedContent" value="package com.example.oportunyfam.Service&#10;&#10;import com.example.oportunyfam.model.*&#10;import retrofit2.Call&#10;import retrofit2.http.*&#10;&#10;interface AtividadeService {&#10;&#10;    // --- ROTAS DE ATIVIDADE ---&#10;&#10;    // POST /atividades/ - Criar atividade&#10;    @Headers(&quot;Content-Type: application/json&quot;)&#10;    @POST(&quot;atividades&quot;)&#10;    fun criarAtividade(@Body atividade: AtividadeRequest): Call&lt;AtividadeCriadaResponse&gt;&#10;&#10;    // GET /atividades/ - Buscar todas as atividades&#10;    @GET(&quot;atividades&quot;)&#10;    fun buscarTodasAtividades(): Call&lt;AtividadesListResponse&gt;&#10;&#10;    // GET /atividades/:id - Buscar atividade por ID&#10;    @GET(&quot;atividades/{id}&quot;)&#10;    fun buscarAtividadePorId(@Path(&quot;id&quot;) id: Int): Call&lt;AtividadeUnicaResponse&gt;&#10;&#10;    // GET /atividades/instituicao/:idInstituicao - Buscar atividades por instituição&#10;    @GET(&quot;atividades/instituicao/{idInstituicao}&quot;)&#10;    fun buscarAtividadesPorInstituicao(@Path(&quot;idInstituicao&quot;) idInstituicao: Int): Call&lt;AtividadesListResponse&gt;&#10;&#10;    // PUT /atividades/:id - Atualizar atividade&#10;    @Headers(&quot;Content-Type: application/json&quot;)&#10;    @PUT(&quot;atividades/{id}&quot;)&#10;    fun atualizarAtividade(@Path(&quot;id&quot;) id: Int, @Body atividade: AtividadeRequest): Call&lt;AtividadeCriadaResponse&gt;&#10;&#10;    // DELETE /atividades/:id - Deletar atividade&#10;    @DELETE(&quot;atividades/{id}&quot;)&#10;    fun deletarAtividade(@Path(&quot;id&quot;) id: Int): Call&lt;Unit&gt;&#10;&#10;    // --- ROTAS DE AULAS ---&#10;&#10;    // POST /aulas/ - Criar uma única aula&#10;    @Headers(&quot;Content-Type: application/json&quot;)&#10;    @POST(&quot;aulas&quot;)&#10;    fun criarAula(@Body aula: AulaRequest): Call&lt;AulaCriadaResponse&gt;&#10;&#10;    // POST /aulas/lote - Criar várias aulas de uma vez&#10;    @Headers(&quot;Content-Type: application/json&quot;)&#10;    @POST(&quot;aulas/lote&quot;)&#10;    fun criarAulasLote(@Body aulaLote: AulaLoteRequest): Call&lt;AulaLoteResponse&gt;&#10;&#10;    // GET /aulas/:id - Buscar aula por ID&#10;    @GET(&quot;aulas/{id}&quot;)&#10;    fun buscarAulaPorId(@Path(&quot;id&quot;) id: Int): Call&lt;AulaCriadaResponse&gt;&#10;&#10;    // PUT /aulas/:id - Atualizar aula&#10;    @Headers(&quot;Content-Type: application/json&quot;)&#10;    @PUT(&quot;aulas/{id}&quot;)&#10;    fun atualizarAula(@Path(&quot;id&quot;) id: Int, @Body aula: AulaRequest): Call&lt;AulaCriadaResponse&gt;&#10;&#10;    // DELETE /aulas/:id - Deletar aula&#10;    @DELETE(&quot;aulas/{id}&quot;)&#10;    fun deletarAula(@Path(&quot;id&quot;) id: Int): Call&lt;Unit&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/model/AtividadeRequest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/model/AtividadeRequest.kt" />
              <option name="originalContent" value="package com.example.oportunyfam.model&#10;&#10;data class AtividadeRequest(&#10;    val id: Int? = null, // Para PUT&#10;    val id_instituicao: Int, // Chave estrangeira obrigatória&#10;    val id_categoria: Int, // Chave estrangeira obrigatória&#10;    val titulo: String,&#10;    val descricao: String? = null,&#10;    val faixa_etaria_min: Int,&#10;    val faixa_etaria_max: Int,&#10;    val gratuita: Boolean = true,&#10;    val preco: Double = 0.0,&#10;    val ativo: Boolean = true&#10;)" />
              <option name="updatedContent" value="package com.example.oportunyfam.model&#10;&#10;// Request para criar/atualizar atividade&#10;data class AtividadeRequest(&#10;    val id_instituicao: Int,&#10;    val id_categoria: Int,&#10;    val titulo: String,&#10;    val descricao: String,&#10;    val faixa_etaria_min: Int,&#10;    val faixa_etaria_max: Int,&#10;    val gratuita: Boolean = true,&#10;    val preco: Double = 0.0,&#10;    val ativo: Boolean = true&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/model/AtividadeResponse.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/model/AtividadeResponse.kt" />
              <option name="originalContent" value="package com.example.oportunyfam.model&#10;&#10;&#10;data class AtividadeResponse(&#10;    val atividade_id: Int, // Mapeia para 'atividade_id' da View&#10;    val titulo: String,&#10;    val descricao: String? = null,&#10;    val faixa_etaria_min: Int,&#10;    val faixa_etaria_max: Int,&#10;    val gratuita: Boolean,&#10;    val preco: Double,&#10;    val ativo: Boolean,&#10;&#10;    // CAMPOS JOIN DA VIEW&#10;    val categoria: String, // c.nome AS categoria&#10;    val instituicao_id: Int,&#10;    val instituicao: String, // i.nome AS instituicao&#10;    val cidade: String,&#10;    val estado: String,&#10;&#10;    // ARRAY DE HORÁRIOS DA VIEW&#10;    val horarios: List&lt;HorarioDetalhe&gt; // Lista da classe definida acima (AulaResponse simplificada)&#10;)" />
              <option name="updatedContent" value="package com.example.oportunyfam.model&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;// Response para atividade simples (após cadastro)&#10;data class AtividadeCriadaResponse(&#10;    val status: Boolean,&#10;    val status_code: Int,&#10;    val messagem: String,&#10;    val atividade: AtividadeSimples&#10;)&#10;&#10;data class AtividadeSimples(&#10;    val id: Int,&#10;    val id_instituicao: Int,&#10;    val id_categoria: Int,&#10;    val titulo: String,&#10;    val descricao: String,&#10;    val faixa_etaria_min: Int,&#10;    val faixa_etaria_max: Int,&#10;    val gratuita: Boolean,&#10;    val preco: String,&#10;    val ativo: Boolean&#10;)&#10;&#10;// Response para lista de atividades (com detalhes completos)&#10;data class AtividadesListResponse(&#10;    val status: Boolean,&#10;    val status_code: Int,&#10;    val messagem: String,&#10;    val atividades: List&lt;AtividadeResponse&gt;&#10;)&#10;&#10;// Response para atividade única (com detalhes completos)&#10;data class AtividadeUnicaResponse(&#10;    val status: Boolean,&#10;    val status_code: Int,&#10;    val messagem: String,&#10;    val atividade: AtividadeResponse&#10;)&#10;&#10;// Atividade com detalhes completos e aulas&#10;data class AtividadeResponse(&#10;    val atividade_id: Int,&#10;    val titulo: String,&#10;    val descricao: String,&#10;    val faixa_etaria_min: Int,&#10;    val faixa_etaria_max: Int,&#10;    val gratuita: Int, // 0 ou 1&#10;    val preco: Double,&#10;    val ativo: Int, // 0 ou 1&#10;    val categoria: String,&#10;    val instituicao_id: Int,&#10;    val instituicao_nome: String,&#10;    val instituicao_foto: String?,&#10;    val cidade: String,&#10;    val estado: String,&#10;    val aulas: List&lt;AulaDetalhe&gt;&#10;)&#10;&#10;// Detalhes de uma aula dentro da atividade&#10;data class AulaDetalhe(&#10;    val status: String, // &quot;Futura&quot; ou &quot;Encerrada&quot;&#10;    val aula_id: Int,&#10;    val hora_fim: String,&#10;    val data_aula: String,&#10;    val hora_inicio: String,&#10;    val vagas_total: Int,&#10;    val vagas_disponiveis: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/model/AulaRequest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/model/AulaRequest.kt" />
              <option name="originalContent" value="package com.example.oportunyfam.model&#10;&#10;import java.time.LocalTime&#10;&#10;data class AulaRequest(&#10;    val id: Int? = null, // Para PUT&#10;    val id_atividade: Int, // Chave estrangeira obrigatória&#10;    val dia_semana: Int, // 1=Dom, 2=Seg, ...&#10;    val hora_inicio: LocalTime,&#10;    val hora_fim: LocalTime,&#10;    val vagas_total: Int,&#10;    val vagas_disponiveis: Int, // Opcional, pode ser calculado no backend&#10;    val ativo: Boolean = true&#10;)" />
              <option name="updatedContent" value="package com.example.oportunyfam.model&#10;&#10;// Request para criar uma única aula&#10;data class AulaRequest(&#10;    val id_atividade: Int,&#10;    val data_aula: String, // Formato: &quot;YYYY-MM-DD&quot;&#10;    val hora_inicio: String, // Formato: &quot;HH:MM:SS&quot;&#10;    val hora_fim: String, // Formato: &quot;HH:MM:SS&quot;&#10;    val vagas_total: Int&#10;)&#10;&#10;// Request para criar várias aulas em lote&#10;data class AulaLoteRequest(&#10;    val id_atividade: Int,&#10;    val hora_inicio: String, // Formato: &quot;HH:MM:SS&quot;&#10;    val hora_fim: String, // Formato: &quot;HH:MM:SS&quot;&#10;    val vagas_total: Int,&#10;    val datas: List&lt;String&gt; // Lista de datas no formato: &quot;YYYY-MM-DD&quot;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/model/AulaResponse.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/model/AulaResponse.kt" />
              <option name="originalContent" value="package com.example.oportunyfam.model&#10;&#10;import java.time.LocalTime&#10;&#10;data class HorarioDetalhe(&#10;    val id: Int,&#10;    val dia_semana: Int,&#10;    val inicio: LocalTime, // Mapeia para 'inicio' no JSON_OBJECT da View&#10;    val fim: LocalTime,    // Mapeia para 'fim' no JSON_OBJECT da View&#10;    val vagas_total: Int,&#10;    val vagas_disponiveis: Int&#10;)&#10;// Esta classe é a estrutura do array JSON retornado pelo backend&#10;data class AulaResponse(&#10;    val id: Int,&#10;    val id_atividade: Int,&#10;    val dia_semana: Int,&#10;    val hora_inicio: LocalTime,&#10;    val hora_fim: LocalTime,&#10;    val vagas_total: Int,&#10;    val vagas_disponiveis: Int,&#10;    val ativo: Boolean&#10;)" />
              <option name="updatedContent" value="package com.example.oportunyfam.model&#10;&#10;// Response para aula única criada&#10;data class AulaCriadaResponse(&#10;    val status: Boolean,&#10;    val status_code: Int,&#10;    val messagem: String,&#10;    val aula: AulaResponse&#10;)&#10;&#10;// Response para aula&#10;data class AulaResponse(&#10;    val id: Int,&#10;    val id_atividade: Int,&#10;    val data_aula: String,&#10;    val hora_inicio: String,&#10;    val hora_fim: String,&#10;    val vagas_total: Int,&#10;    val vagas_disponiveis: Int&#10;)&#10;&#10;// Response para criação em lote de aulas&#10;data class AulaLoteResponse(&#10;    val status: Boolean,&#10;    val status_code: Int,&#10;    val messagem: String,&#10;    val aulas_inseridas: List&lt;AulaResponse&gt;,&#10;    val total_inseridas: Int,&#10;    val erros: Any? // null ou lista de erros&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/oportunyfam_mobile_ong/Screens/ChatScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/oportunyfam_mobile_ong/Screens/ChatScreen.kt" />
              <option name="originalContent" value="package com.example.oportunyfam_mobile_ong.Screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.Send&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.oportunyfam_mobile_ong.model.Mensagem&#10;import com.example.oportunyfam_mobile_ong.viewmodel.ChatViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatScreen(&#10;    navController: NavHostController,&#10;    conversaId: Int,&#10;    nomeContato: String,&#10;    pessoaIdAtual: Int,&#10;    viewModel: ChatViewModel = viewModel()&#10;) {&#10;    val mensagens by viewModel.mensagens.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val errorMessage by viewModel.errorMessage.collectAsState()&#10;    var currentMessage by remember { mutableStateOf(&quot;&quot;) }&#10;    val listState = rememberLazyListState()&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Carregar mensagens e iniciar escuta em tempo real do Firebase&#10;    LaunchedEffect(conversaId) {&#10;        viewModel.iniciarEscutaMensagens(conversaId)&#10;    }&#10;&#10;    // Scroll automático para a última mensagem&#10;    LaunchedEffect(mensagens.size) {&#10;        if (mensagens.isNotEmpty()) {&#10;            coroutineScope.launch {&#10;                listState.animateScrollToItem(mensagens.size - 1)&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            ChatTopBar(&#10;                nomeContato = nomeContato,&#10;                onBackClick = { navController.popBackStack() }&#10;            )&#10;        },&#10;        containerColor = Color(0xFFF5F5F5)&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Mensagens de erro&#10;            errorMessage?.let { error -&gt;&#10;                Surface(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    color = Color(0xFFFFEBEE)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(8.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = error,&#10;                            color = Color(0xFFD32F2F),&#10;                            fontSize = 12.sp,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                        TextButton(onClick = { viewModel.limparErro() }) {&#10;                            Text(&quot;OK&quot;, color = Color(0xFFD32F2F))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Lista de mensagens&#10;            Box(modifier = Modifier.weight(1f)) {&#10;                when {&#10;                    isLoading &amp;&amp; mensagens.isEmpty() -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator(color = Color(0xFFFF6F00))&#10;                        }&#10;                    }&#10;                    mensagens.isEmpty() -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhuma mensagem ainda\nSeja o primeiro a enviar!&quot;,&#10;                                color = Color.Gray,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        LazyColumn(&#10;                            state = listState,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentPadding = PaddingValues(horizontal = 8.dp, vertical = 8.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            items(mensagens) { mensagem -&gt;&#10;                                ChatMessage(&#10;                                    mensagem = mensagem,&#10;                                    isUser = mensagem.id_pessoa == pessoaIdAtual&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Campo de entrada&#10;            ChatInputField(&#10;                currentMessage = currentMessage,&#10;                onMessageChange = { currentMessage = it },&#10;                onSendClick = {&#10;                    if (currentMessage.isNotBlank()) {&#10;                        viewModel.enviarMensagem(conversaId, pessoaIdAtual, currentMessage)&#10;                        currentMessage = &quot;&quot;&#10;                    }&#10;                },&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatTopBar(nomeContato: String, onBackClick: () -&gt; Unit) {&#10;    val gradient = Brush.horizontalGradient(&#10;        colors = listOf(Color(0xFFFFA726), Color(0xFFF57C00))&#10;    )&#10;&#10;    TopAppBar(&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(40.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color.White)&#10;                ) {&#10;                    Text(&#10;                        text = nomeContato.firstOrNull()?.uppercase() ?: &quot;?&quot;,&#10;                        modifier = Modifier.align(Alignment.Center),&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFFFF6F00)&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;                Column {&#10;                    Text(&#10;                        text = nomeContato,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp,&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                    Text(&#10;                        text = &quot;Online&quot;,&#10;                        fontSize = 12.sp,&#10;                        color = Color.White.copy(alpha = 0.8f)&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = onBackClick) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Voltar&quot;,&#10;                    tint = Color.White&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = Color.Transparent,&#10;            titleContentColor = Color.White&#10;        ),&#10;        modifier = Modifier.background(gradient)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ChatMessage(mensagem: Mensagem, isUser: Boolean) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 4.dp),&#10;        horizontalArrangement = if (isUser) Arrangement.End else Arrangement.Start&#10;    ) {&#10;        Card(&#10;            modifier = Modifier.widthIn(max = 280.dp),&#10;            shape = RoundedCornerShape(&#10;                topStart = 16.dp,&#10;                topEnd = 16.dp,&#10;                bottomStart = if (isUser) 16.dp else 4.dp,&#10;                bottomEnd = if (isUser) 4.dp else 16.dp&#10;            ),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = if (isUser) Color(0xFFDCF8C6) else Color.White&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = mensagem.descricao,&#10;                    fontSize = 15.sp,&#10;                    color = Color.Black&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Row(&#10;                    horizontalArrangement = Arrangement.End,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&#10;                        text = formatarHora(mensagem.criado_em),&#10;                        fontSize = 11.sp,&#10;                        color = Color.Gray&#10;                    )&#10;                    if (isUser) {&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = if (mensagem.visto) &quot;✓✓&quot; else &quot;✓&quot;,&#10;                            fontSize = 11.sp,&#10;                            color = if (mensagem.visto) Color(0xFF4CAF50) else Color.Gray&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ChatInputField(&#10;    currentMessage: String,&#10;    onMessageChange: (String) -&gt; Unit,&#10;    onSendClick: () -&gt; Unit,&#10;    enabled: Boolean&#10;) {&#10;    Surface(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        color = Color.White,&#10;        shadowElevation = 8.dp&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 8.dp, vertical = 8.dp),&#10;            verticalAlignment = Alignment.Bottom&#10;        ) {&#10;            OutlinedTextField(&#10;                value = currentMessage,&#10;                onValueChange = onMessageChange,&#10;                modifier = Modifier.weight(1f),&#10;                placeholder = { Text(&quot;Digite uma mensagem...&quot;, fontSize = 14.sp) },&#10;                shape = RoundedCornerShape(24.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFFFF6F00),&#10;                    unfocusedBorderColor = Color(0xFFE0E0E0)&#10;                ),&#10;                maxLines = 4,&#10;                enabled = enabled&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            FloatingActionButton(&#10;                onClick = onSendClick,&#10;                modifier = Modifier.size(48.dp),&#10;                containerColor = Color(0xFFFF6F00),&#10;                contentColor = Color.White,&#10;                elevation = FloatingActionButtonDefaults.elevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.Send,&#10;                    contentDescription = &quot;Enviar&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatarHora(dataHora: String): String {&#10;    return try {&#10;        val partes = dataHora.split(&quot;T&quot;)&#10;        if (partes.size &gt; 1) {&#10;            partes[1].substring(0, 5)&#10;        } else {&#10;            &quot;Agora&quot;&#10;        }&#10;    } catch (e: Exception) {&#10;        &quot;Agora&quot;&#10;    }&#10;}&#10;&#10;@Preview(showSystemUi = true)&#10;@Composable&#10;fun ChatScreenPreview() {&#10;    ChatScreen(&#10;        navController = rememberNavController(),&#10;        conversaId = 1,&#10;        nomeContato = &quot;Laura de Andrade&quot;,&#10;        pessoaIdAtual = 1&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.example.oportunyfam_mobile_ong.Screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.Send&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.oportunyfam_mobile_ong.model.Mensagem&#10;import com.example.oportunyfam_mobile_ong.viewmodel.ChatViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatScreen(&#10;    navController: NavHostController,&#10;    conversaId: Int,&#10;    nomeContato: String,&#10;    pessoaIdAtual: Int,&#10;    viewModel: ChatViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;) {&#10;    val mensagens by viewModel.mensagens.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val errorMessage by viewModel.errorMessage.collectAsState()&#10;    var currentMessage by remember { mutableStateOf(&quot;&quot;) }&#10;    val listState = rememberLazyListState()&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Carregar mensagens e iniciar escuta em tempo real do Firebase&#10;    LaunchedEffect(conversaId) {&#10;        viewModel.iniciarEscutaMensagens(conversaId)&#10;    }&#10;&#10;    // Scroll automático para a última mensagem&#10;    LaunchedEffect(mensagens.size) {&#10;        if (mensagens.isNotEmpty()) {&#10;            coroutineScope.launch {&#10;                listState.animateScrollToItem(mensagens.size - 1)&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            ChatTopBar(&#10;                nomeContato = nomeContato,&#10;                onBackClick = { navController.popBackStack() }&#10;            )&#10;        },&#10;        containerColor = Color(0xFFF5F5F5)&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Mensagens de erro&#10;            errorMessage?.let { error -&gt;&#10;                Surface(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    color = Color(0xFFFFEBEE)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(8.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = error,&#10;                            color = Color(0xFFD32F2F),&#10;                            fontSize = 12.sp,&#10;                            modifier = Modifier.weight(1f)&#10;                        )&#10;                        TextButton(onClick = { viewModel.limparErro() }) {&#10;                            Text(&quot;OK&quot;, color = Color(0xFFD32F2F))&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Lista de mensagens&#10;            Box(modifier = Modifier.weight(1f)) {&#10;                when {&#10;                    isLoading &amp;&amp; mensagens.isEmpty() -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator(color = Color(0xFFFF6F00))&#10;                        }&#10;                    }&#10;                    mensagens.isEmpty() -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhuma mensagem ainda\nSeja o primeiro a enviar!&quot;,&#10;                                color = Color.Gray,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        LazyColumn(&#10;                            state = listState,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentPadding = PaddingValues(horizontal = 8.dp, vertical = 8.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                        ) {&#10;                            items(mensagens) { mensagem -&gt;&#10;                                ChatMessage(&#10;                                    mensagem = mensagem,&#10;                                    isUser = mensagem.id_pessoa == pessoaIdAtual&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Campo de entrada&#10;            ChatInputField(&#10;                currentMessage = currentMessage,&#10;                onMessageChange = { currentMessage = it },&#10;                onSendClick = {&#10;                    if (currentMessage.isNotBlank()) {&#10;                        viewModel.enviarMensagem(conversaId, pessoaIdAtual, currentMessage)&#10;                        currentMessage = &quot;&quot;&#10;                    }&#10;                },&#10;                enabled = !isLoading&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChatTopBar(nomeContato: String, onBackClick: () -&gt; Unit) {&#10;    val gradient = Brush.horizontalGradient(&#10;        colors = listOf(Color(0xFFFFA726), Color(0xFFF57C00))&#10;    )&#10;&#10;    TopAppBar(&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(40.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color.White)&#10;                ) {&#10;                    Text(&#10;                        text = nomeContato.firstOrNull()?.uppercase() ?: &quot;?&quot;,&#10;                        modifier = Modifier.align(Alignment.Center),&#10;                        fontSize = 18.sp,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color(0xFFFF6F00)&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;                Column {&#10;                    Text(&#10;                        text = nomeContato,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 18.sp,&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                    Text(&#10;                        text = &quot;Online&quot;,&#10;                        fontSize = 12.sp,&#10;                        color = Color.White.copy(alpha = 0.8f)&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        navigationIcon = {&#10;            IconButton(onClick = onBackClick) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                    contentDescription = &quot;Voltar&quot;,&#10;                    tint = Color.White&#10;                )&#10;            }&#10;        },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = Color.Transparent,&#10;            titleContentColor = Color.White&#10;        ),&#10;        modifier = Modifier.background(gradient)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ChatMessage(mensagem: Mensagem, isUser: Boolean) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 4.dp),&#10;        horizontalArrangement = if (isUser) Arrangement.End else Arrangement.Start&#10;    ) {&#10;        Card(&#10;            modifier = Modifier.widthIn(max = 280.dp),&#10;            shape = RoundedCornerShape(&#10;                topStart = 16.dp,&#10;                topEnd = 16.dp,&#10;                bottomStart = if (isUser) 16.dp else 4.dp,&#10;                bottomEnd = if (isUser) 4.dp else 16.dp&#10;            ),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = if (isUser) Color(0xFFDCF8C6) else Color.White&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = mensagem.descricao,&#10;                    fontSize = 15.sp,&#10;                    color = Color.Black&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Row(&#10;                    horizontalArrangement = Arrangement.End,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&#10;                        text = formatarHora(mensagem.criado_em),&#10;                        fontSize = 11.sp,&#10;                        color = Color.Gray&#10;                    )&#10;                    if (isUser) {&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = if (mensagem.visto) &quot;✓✓&quot; else &quot;✓&quot;,&#10;                            fontSize = 11.sp,&#10;                            color = if (mensagem.visto) Color(0xFF4CAF50) else Color.Gray&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ChatInputField(&#10;    currentMessage: String,&#10;    onMessageChange: (String) -&gt; Unit,&#10;    onSendClick: () -&gt; Unit,&#10;    enabled: Boolean&#10;) {&#10;    Surface(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        color = Color.White,&#10;        shadowElevation = 8.dp&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 8.dp, vertical = 8.dp),&#10;            verticalAlignment = Alignment.Bottom&#10;        ) {&#10;            OutlinedTextField(&#10;                value = currentMessage,&#10;                onValueChange = onMessageChange,&#10;                modifier = Modifier.weight(1f),&#10;                placeholder = { Text(&quot;Digite uma mensagem...&quot;, fontSize = 14.sp) },&#10;                shape = RoundedCornerShape(24.dp),&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedBorderColor = Color(0xFFFF6F00),&#10;                    unfocusedBorderColor = Color(0xFFE0E0E0)&#10;                ),&#10;                maxLines = 4,&#10;                enabled = enabled&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            FloatingActionButton(&#10;                onClick = onSendClick,&#10;                modifier = Modifier.size(48.dp),&#10;                containerColor = Color(0xFFFF6F00),&#10;                contentColor = Color.White,&#10;                elevation = FloatingActionButtonDefaults.elevation(defaultElevation = 4.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.AutoMirrored.Filled.Send,&#10;                    contentDescription = &quot;Enviar&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatarHora(dataHora: String): String {&#10;    return try {&#10;        val partes = dataHora.split(&quot;T&quot;)&#10;        if (partes.size &gt; 1) {&#10;            partes[1].substring(0, 5)&#10;        } else {&#10;            &quot;Agora&quot;&#10;        }&#10;    } catch (e: Exception) {&#10;        &quot;Agora&quot;&#10;    }&#10;}&#10;&#10;@Preview(showSystemUi = true)&#10;@Composable&#10;fun ChatScreenPreview() {&#10;    ChatScreen(&#10;        navController = rememberNavController(),&#10;        conversaId = 1,&#10;        nomeContato = &quot;Laura de Andrade&quot;,&#10;        pessoaIdAtual = 1&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/oportunyfam_mobile_ong/Screens/ConversasScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/oportunyfam_mobile_ong/Screens/ConversasScreen.kt" />
              <option name="originalContent" value="package com.example.oportunyfam_mobile_ong.Screens&#10;&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.*&#10;import androidx.compose.ui.draw.*&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.example.oportunyfam_mobile_ong.Components.BarraTarefas&#10;import com.example.oportunyfam_mobile_ong.R&#10;import com.example.oportunyfam_mobile_ong.viewmodel.ChatViewModel&#10;import com.example.oportunyfam_mobile_ong.viewmodel.ConversaUI&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ConversasScreen(&#10;    navController: NavHostController?,&#10;    viewModel: ChatViewModel = viewModel()&#10;) {&#10;    val conversas by viewModel.conversas.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val errorMessage by viewModel.errorMessage.collectAsState()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // Carrega conversas apenas na primeira vez&#10;        // O ViewModel controla para não fazer requisições duplicadas&#10;        viewModel.carregarConversas()&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = { ConversasTopBarPremium() },&#10;        bottomBar = { BarraTarefas(navController, &quot;ConversasScreen&quot;) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = { /* TODO: Abrir diálogo para nova conversa */ },&#10;                containerColor = Color(0xFFFF6F00),&#10;                contentColor = Color.White&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Nova conversa&quot;)&#10;            }&#10;        },&#10;        containerColor = Color(0xFFF5F5F5)&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            when {&#10;                isLoading &amp;&amp; conversas.isEmpty() -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator(color = Color(0xFFFF6F00))&#10;                    }&#10;                }&#10;                errorMessage != null -&gt; {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.Center&#10;                    ) {&#10;                        Text(&#10;                            text = errorMessage ?: &quot;Erro desconhecido&quot;,&#10;                            color = Color.Red,&#10;                            textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                        )&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Button(onClick = { viewModel.carregarConversas() }) {&#10;                            Text(&quot;Tentar novamente&quot;)&#10;                        }&#10;                    }&#10;                }&#10;                conversas.isEmpty() -&gt; {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(32.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.Center&#10;                    ) {&#10;                        Icon(&#10;                            painter = painterResource(id = R.drawable.logo),&#10;                            contentDescription = &quot;Sem conversas&quot;,&#10;                            modifier = Modifier.size(100.dp),&#10;                            tint = Color.Gray&#10;                        )&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Text(&#10;                            text = &quot;Nenhuma conversa ainda&quot;,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.Gray&#10;                        )&#10;                        Text(&#10;                            text = &quot;Suas conversas aparecerão aqui&quot;,&#10;                            fontSize = 14.sp,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    ConversaListPremium(&#10;                        conversas = conversas,&#10;                        onConversaClick = { conversa -&gt;&#10;                            navController?.navigate(&quot;ChatScreen/${conversa.id}/${conversa.nome}/${conversa.pessoaId}&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ConversasTopBarPremium() {&#10;    val gradient = Brush.horizontalGradient(&#10;        colors = listOf(Color(0xFFFFA726), Color(0xFFF57C00))&#10;    )&#10;    TopAppBar(&#10;        title = { Text(&quot;Conversas&quot;, fontWeight = FontWeight.Bold, fontSize = 22.sp) },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = Color.Transparent,&#10;            titleContentColor = Color.White&#10;        ),&#10;        modifier = Modifier&#10;            .background(gradient)&#10;            .fillMaxWidth(),&#10;        actions = {&#10;            IconButton(onClick = { /* ação */ }) {&#10;                Icon(&#10;                    painter = painterResource(id = R.drawable.logo),&#10;                    contentDescription = &quot;Logo&quot;,&#10;                    tint = Color.White&#10;                )&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ConversaListPremium(&#10;    conversas: List&lt;ConversaUI&gt;,&#10;    onConversaClick: (ConversaUI) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    LazyColumn(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentPadding = PaddingValues(vertical = 8.dp, horizontal = 8.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        items(conversas) { conversa -&gt;&#10;            ConversaItemPremium(&#10;                conversa = conversa,&#10;                onClick = { onConversaClick(conversa) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AvatarDegrade(imagem: Int, online: Boolean) {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;avatar_animation&quot;)&#10;    val animatedOffset by infiniteTransition.animateFloat(&#10;        initialValue = 0f,&#10;        targetValue = 100f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(2000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Reverse&#10;        ),&#10;        label = &quot;avatar_offset&quot;&#10;    )&#10;&#10;    val gradient = Brush.linearGradient(&#10;        colors = listOf(Color(0xFFFFA726), Color(0xFFF57C00), Color(0xFFFFA726)),&#10;        start = Offset(animatedOffset, 0f),&#10;        end = Offset(100f + animatedOffset, 100f)&#10;    )&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .size(60.dp)&#10;            .clip(CircleShape)&#10;            .border(width = 3.dp, brush = gradient, shape = CircleShape)&#10;    ) {&#10;        Image(&#10;            painter = painterResource(id = imagem),&#10;            contentDescription = &quot;Avatar&quot;,&#10;            contentScale = ContentScale.Crop,&#10;            modifier = Modifier&#10;                .size(55.dp)&#10;                .clip(CircleShape)&#10;                .align(Alignment.Center)&#10;        )&#10;        if (online) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(16.dp)&#10;                    .background(Color(0xFF4CAF50), CircleShape)&#10;                    .border(2.dp, Color.White, CircleShape)&#10;                    .align(Alignment.BottomEnd)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConversaItemPremium(conversa: ConversaUI, onClick: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(20.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.White),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            AvatarDegrade(imagem = conversa.imagem, online = conversa.online)&#10;&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(conversa.nome, fontWeight = FontWeight.Bold, fontSize = 17.sp)&#10;                Spacer(modifier = Modifier.height(2.dp))&#10;                Text(&#10;                    conversa.ultimaMensagem,&#10;                    color = Color.Gray,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;&#10;            Column(horizontalAlignment = Alignment.End) {&#10;                Text(conversa.hora, color = Color(0xFF616161), fontWeight = FontWeight.SemiBold, fontSize = 13.sp)&#10;                if (conversa.mensagensNaoLidas &gt; 0) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .padding(top = 4.dp)&#10;                            .size(20.dp)&#10;                            .background(Color(0xFFD32F2F), CircleShape),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&quot;${conversa.mensagensNaoLidas}&quot;, color = Color.White, fontSize = 12.sp, fontWeight = FontWeight.Bold)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun PreviewConversasScreen() {&#10;    ConversasScreen(null)&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.oportunyfam_mobile_ong.Screens&#10;&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.*&#10;import androidx.compose.ui.draw.*&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavHostController&#10;import com.example.oportunyfam_mobile_ong.Components.BarraTarefas&#10;import com.example.oportunyfam_mobile_ong.R&#10;import com.example.oportunyfam_mobile_ong.viewmodel.ChatViewModel&#10;import com.example.oportunyfam_mobile_ong.viewmodel.ConversaUI&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ConversasScreen(&#10;    navController: NavHostController?,&#10;    viewModel: ChatViewModel = androidx.lifecycle.viewmodel.compose.viewModel()&#10;) {&#10;    val conversas by viewModel.conversas.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    val errorMessage by viewModel.errorMessage.collectAsState()&#10;    val instituicaoId by viewModel.instituicaoId.collectAsState()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // Carrega conversas apenas na primeira vez&#10;        // O ViewModel controla para não fazer requisições duplicadas&#10;        viewModel.carregarConversas()&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = { ConversasTopBarPremium() },&#10;        bottomBar = { BarraTarefas(navController, &quot;ConversasScreen&quot;) },&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = { /* TODO: Abrir diálogo para nova conversa */ },&#10;                containerColor = Color(0xFFFF6F00),&#10;                contentColor = Color.White&#10;            ) {&#10;                Icon(Icons.Filled.Add, contentDescription = &quot;Nova conversa&quot;)&#10;            }&#10;        },&#10;        containerColor = Color(0xFFF5F5F5)&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            when {&#10;                isLoading &amp;&amp; conversas.isEmpty() -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator(color = Color(0xFFFF6F00))&#10;                    }&#10;                }&#10;                errorMessage != null -&gt; {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.Center&#10;                    ) {&#10;                        Text(&#10;                            text = errorMessage ?: &quot;Erro desconhecido&quot;,&#10;                            color = Color.Red,&#10;                            textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                        )&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Button(onClick = { viewModel.carregarConversas() }) {&#10;                            Text(&quot;Tentar novamente&quot;)&#10;                        }&#10;                    }&#10;                }&#10;                conversas.isEmpty() -&gt; {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(32.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.Center&#10;                    ) {&#10;                        Icon(&#10;                            painter = painterResource(id = R.drawable.logo),&#10;                            contentDescription = &quot;Sem conversas&quot;,&#10;                            modifier = Modifier.size(100.dp),&#10;                            tint = Color.Gray&#10;                        )&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Text(&#10;                            text = &quot;Nenhuma conversa ainda&quot;,&#10;                            fontSize = 18.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.Gray&#10;                        )&#10;                        Text(&#10;                            text = &quot;Suas conversas aparecerão aqui&quot;,&#10;                            fontSize = 14.sp,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    ConversaListPremium(&#10;                        conversas = conversas,&#10;                        onConversaClick = { conversa -&gt;&#10;                            // ✅ CORRIGIDO: Passa o ID da instituição logada, não o ID da outra pessoa&#10;                            val instId = instituicaoId ?: 0&#10;                            navController?.navigate(&quot;ChatScreen/${conversa.id}/${conversa.nome}/$instId&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ConversasTopBarPremium() {&#10;    val gradient = Brush.horizontalGradient(&#10;        colors = listOf(Color(0xFFFFA726), Color(0xFFF57C00))&#10;    )&#10;    TopAppBar(&#10;        title = { Text(&quot;Conversas&quot;, fontWeight = FontWeight.Bold, fontSize = 22.sp) },&#10;        colors = TopAppBarDefaults.topAppBarColors(&#10;            containerColor = Color.Transparent,&#10;            titleContentColor = Color.White&#10;        ),&#10;        modifier = Modifier&#10;            .background(gradient)&#10;            .fillMaxWidth(),&#10;        actions = {&#10;            IconButton(onClick = { /* ação */ }) {&#10;                Icon(&#10;                    painter = painterResource(id = R.drawable.logo),&#10;                    contentDescription = &quot;Logo&quot;,&#10;                    tint = Color.White&#10;                )&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun ConversaListPremium(&#10;    conversas: List&lt;ConversaUI&gt;,&#10;    onConversaClick: (ConversaUI) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    LazyColumn(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentPadding = PaddingValues(vertical = 8.dp, horizontal = 8.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        items(conversas) { conversa -&gt;&#10;            ConversaItemPremium(&#10;                conversa = conversa,&#10;                onClick = { onConversaClick(conversa) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AvatarDegrade(imagem: Int, online: Boolean) {&#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;avatar_animation&quot;)&#10;    val animatedOffset by infiniteTransition.animateFloat(&#10;        initialValue = 0f,&#10;        targetValue = 100f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(2000, easing = LinearEasing),&#10;            repeatMode = RepeatMode.Reverse&#10;        ),&#10;        label = &quot;avatar_offset&quot;&#10;    )&#10;&#10;    val gradient = Brush.linearGradient(&#10;        colors = listOf(Color(0xFFFFA726), Color(0xFFF57C00), Color(0xFFFFA726)),&#10;        start = Offset(animatedOffset, 0f),&#10;        end = Offset(100f + animatedOffset, 100f)&#10;    )&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .size(60.dp)&#10;            .clip(CircleShape)&#10;            .border(width = 3.dp, brush = gradient, shape = CircleShape)&#10;    ) {&#10;        Image(&#10;            painter = painterResource(id = imagem),&#10;            contentDescription = &quot;Avatar&quot;,&#10;            contentScale = ContentScale.Crop,&#10;            modifier = Modifier&#10;                .size(55.dp)&#10;                .clip(CircleShape)&#10;                .align(Alignment.Center)&#10;        )&#10;        if (online) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(16.dp)&#10;                    .background(Color(0xFF4CAF50), CircleShape)&#10;                    .border(2.dp, Color.White, CircleShape)&#10;                    .align(Alignment.BottomEnd)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConversaItemPremium(conversa: ConversaUI, onClick: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(20.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.White),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            AvatarDegrade(imagem = conversa.imagem, online = conversa.online)&#10;&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(conversa.nome, fontWeight = FontWeight.Bold, fontSize = 17.sp)&#10;                Spacer(modifier = Modifier.height(2.dp))&#10;                Text(&#10;                    conversa.ultimaMensagem,&#10;                    color = Color.Gray,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;&#10;            Column(horizontalAlignment = Alignment.End) {&#10;                Text(conversa.hora, color = Color(0xFF616161), fontWeight = FontWeight.SemiBold, fontSize = 13.sp)&#10;                if (conversa.mensagensNaoLidas &gt; 0) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .padding(top = 4.dp)&#10;                            .size(20.dp)&#10;                            .background(Color(0xFFD32F2F), CircleShape),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&quot;${conversa.mensagensNaoLidas}&quot;, color = Color.White, fontSize = 12.sp, fontWeight = FontWeight.Bold)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun PreviewConversasScreen() {&#10;    ConversasScreen(null)&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/oportunyfam_mobile_ong/viewmodel/ChatViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/oportunyfam_mobile_ong/viewmodel/ChatViewModel.kt" />
              <option name="originalContent" value="package com.example.oportunyfam_mobile_ong.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.oportunyfam_mobile_ong.Service.FirebaseMensagemService&#10;import com.example.oportunyfam_mobile_ong.Service.MensagemService&#10;import com.example.oportunyfam_mobile_ong.model.Mensagem&#10;import com.example.oportunyfam_mobile_ong.model.MensagemRequest&#10;import com.example.oportunyfam_mobile_ong.Service.InstituicaoService&#10;import com.example.oportunyfam_mobile_ong.Service.RetrofitFactory&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class ConversaUI(&#10;    val id: Int,&#10;    val nome: String,&#10;    val ultimaMensagem: String,&#10;    val hora: String,&#10;    val imagem: Int,&#10;    val online: Boolean,&#10;    val mensagensNaoLidas: Int = 0,&#10;    val pessoaId: Int&#10;)&#10;&#10;class ChatViewModel(&#10;    private val instituicaoId: Int = 6 // TODO: Pegar do AuthDataStore&#10;) : ViewModel() {&#10;    private val instituicaoService: InstituicaoService = RetrofitFactory().getInstituicaoService()&#10;    private val mensagemService: MensagemService = RetrofitFactory().getMensagemService()&#10;    private val firebaseMensagemService: FirebaseMensagemService = FirebaseMensagemService()&#10;&#10;    private val _conversas = MutableStateFlow&lt;List&lt;ConversaUI&gt;&gt;(emptyList())&#10;    val conversas: StateFlow&lt;List&lt;ConversaUI&gt;&gt; = _conversas.asStateFlow()&#10;&#10;    private val _mensagens = MutableStateFlow&lt;List&lt;Mensagem&gt;&gt;(emptyList())&#10;    val mensagens: StateFlow&lt;List&lt;Mensagem&gt;&gt; = _mensagens.asStateFlow()&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _errorMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val errorMessage: StateFlow&lt;String?&gt; = _errorMessage.asStateFlow()&#10;&#10;    // Flag para controlar se já carregou conversas&#10;    private var conversasCarregadas = false&#10;&#10;    /**&#10;     * Carrega conversas apenas na primeira vez que entra na tela&#10;     */&#10;    fun carregarConversas(forcarRecarregar: Boolean = false) {&#10;        if (conversasCarregadas &amp;&amp; !forcarRecarregar) {&#10;            Log.d(&quot;ChatViewModel&quot;, &quot;Conversas já carregadas, pulando requisição&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            try {&#10;                val response = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {&#10;                    instituicaoService.buscarPorId(instituicaoId).execute()&#10;                }&#10;&#10;                if (response.isSuccessful) {&#10;                    val instituicao = response.body()?.instituicao&#10;                    val conversasInstituicao = instituicao?.conversas ?: emptyList()&#10;&#10;                    _conversas.value = conversasInstituicao.map { conversa -&gt;&#10;                        ConversaUI(&#10;                            id = conversa.id_conversa,&#10;                            nome = conversa.outro_participante.nome,&#10;                            ultimaMensagem = conversa.ultima_mensagem?.descricao ?: &quot;Sem mensagens&quot;,&#10;                            hora = formatarHora(conversa.ultima_mensagem?.data_envio),&#10;                            imagem = com.example.oportunyfam_mobile_ong.R.drawable.perfil,&#10;                            online = false,&#10;                            mensagensNaoLidas = 0,&#10;                            pessoaId = conversa.outro_participante.id&#10;                        )&#10;                    }&#10;                    conversasCarregadas = true&#10;                    Log.d(&quot;ChatViewModel&quot;, &quot;Conversas carregadas pela primeira vez: ${_conversas.value.size}&quot;)&#10;                } else {&#10;                    _errorMessage.value = &quot;Erro ao carregar conversas: ${response.message()}&quot;&#10;                    Log.e(&quot;ChatViewModel&quot;, &quot;Erro: ${response.errorBody()?.string()}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Erro ao conectar: ${e.message}&quot;&#10;                Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao carregar conversas&quot;, e)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inicia escuta em tempo real do Firebase para uma conversa&#10;     * Primeiro carrega do backend, depois mantém sincronização em tempo real&#10;     */&#10;    fun iniciarEscutaMensagens(conversaId: Int) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;&#10;                // Primeiro, carrega mensagens do backend&#10;                val response = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {&#10;                    mensagemService.listarPorConversa(conversaId)&#10;                }&#10;&#10;                if (response.isSuccessful) {&#10;                    val mensagensBackend = response.body()?.mensagens ?: emptyList()&#10;                    _mensagens.value = mensagensBackend&#10;                    Log.d(&quot;ChatViewModel&quot;, &quot;Mensagens carregadas do backend: ${mensagensBackend.size}&quot;)&#10;&#10;                    // Sincroniza com Firebase em background (não bloqueia a UI)&#10;                    launch(kotlinx.coroutines.Dispatchers.IO) {&#10;                        try {&#10;                            firebaseMensagemService.sincronizarMensagens(conversaId, mensagensBackend)&#10;                            Log.d(&quot;ChatViewModel&quot;, &quot;Mensagens sincronizadas com Firebase: ${mensagensBackend.size}&quot;)&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao sincronizar mensagens&quot;, e)&#10;                        }&#10;                    }&#10;                } else {&#10;                    _errorMessage.value = &quot;Erro ao carregar mensagens&quot;&#10;                    Log.e(&quot;ChatViewModel&quot;, &quot;Erro: ${response.errorBody()?.string()}&quot;)&#10;                }&#10;&#10;                _isLoading.value = false&#10;&#10;                // Agora escuta mudanças em tempo real do Firebase&#10;                firebaseMensagemService.observarMensagens(conversaId).collect { mensagensAtualizadas -&gt;&#10;                    if (mensagensAtualizadas.isNotEmpty()) {&#10;                        _mensagens.value = mensagensAtualizadas&#10;                        Log.d(&quot;ChatViewModel&quot;, &quot; Mensagens atualizadas EM TEMPO REAL: ${mensagensAtualizadas.size}&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Erro ao carregar mensagens: ${e.message}&quot;&#10;                Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao iniciar escuta de mensagens&quot;, e)&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Envia mensagem: primeiro salva no backend, depois no Firebase&#10;     * O Firebase notifica todos os listeners automaticamente&#10;     */&#10;    fun enviarMensagem(conversaId: Int, pessoaId: Int, texto: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // 1. Envia para o backend (fonte da verdade)&#10;                val request = MensagemRequest(&#10;                    id_conversa = conversaId,&#10;                    id_pessoa = pessoaId,&#10;                    descricao = texto&#10;                )&#10;                val response = mensagemService.criar(request)&#10;&#10;                if (response.isSuccessful) {&#10;                    val mensagemCriada = response.body()?.mensagem&#10;&#10;                    if (mensagemCriada != null) {&#10;                        // 2. Envia para o Firebase (notifica em tempo real)&#10;                        firebaseMensagemService.enviarMensagem(mensagemCriada)&#10;                        Log.d(&quot;ChatViewModel&quot;, &quot;✅ Mensagem enviada: ${mensagemCriada.id}&quot;)&#10;                    }&#10;                } else {&#10;                    _errorMessage.value = &quot;Erro ao enviar mensagem&quot;&#10;                    Log.e(&quot;ChatViewModel&quot;, &quot;Erro: ${response.errorBody()?.string()}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Erro ao enviar: ${e.message}&quot;&#10;                Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao enviar mensagem&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun limparErro() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    private fun formatarHora(dataHora: String?): String {&#10;        if (dataHora == null) return &quot;Agora&quot;&#10;        return try {&#10;            // Formato: &quot;2025-11-06 12:49:09.000000&quot;&#10;            val partes = dataHora.split(&quot; &quot;)&#10;            if (partes.size &gt; 1) {&#10;                val hora = partes[1].substring(0, 5)&#10;                hora&#10;            } else {&#10;                &quot;Agora&quot;&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao formatar hora: $dataHora&quot;, e)&#10;            &quot;Agora&quot;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.oportunyfam_mobile_ong.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.oportunyfam_mobile_ong.Service.FirebaseMensagemService&#10;import com.example.oportunyfam_mobile_ong.Service.MensagemService&#10;import com.example.oportunyfam_mobile_ong.model.Mensagem&#10;import com.example.oportunyfam_mobile_ong.model.MensagemRequest&#10;import com.example.oportunyfam_mobile_ong.Service.InstituicaoService&#10;import com.example.oportunyfam_mobile_ong.Service.RetrofitFactory&#10;import com.example.oportunyfam_mobile_ong.data.InstituicaoAuthDataStore&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class ConversaUI(&#10;    val id: Int,&#10;    val nome: String,&#10;    val ultimaMensagem: String,&#10;    val hora: String,&#10;    val imagem: Int,&#10;    val online: Boolean,&#10;    val mensagensNaoLidas: Int = 0,&#10;    val pessoaId: Int&#10;)&#10;&#10;class ChatViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val instituicaoService: InstituicaoService = RetrofitFactory().getInstituicaoService()&#10;    private val mensagemService: MensagemService = RetrofitFactory().getMensagemService()&#10;    private val firebaseMensagemService: FirebaseMensagemService = FirebaseMensagemService()&#10;    private val authDataStore = InstituicaoAuthDataStore(application)&#10;&#10;    private val _conversas = MutableStateFlow&lt;List&lt;ConversaUI&gt;&gt;(emptyList())&#10;    val conversas: StateFlow&lt;List&lt;ConversaUI&gt;&gt; = _conversas.asStateFlow()&#10;&#10;    private val _mensagens = MutableStateFlow&lt;List&lt;Mensagem&gt;&gt;(emptyList())&#10;    val mensagens: StateFlow&lt;List&lt;Mensagem&gt;&gt; = _mensagens.asStateFlow()&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _errorMessage = MutableStateFlow&lt;String?&gt;(null)&#10;    val errorMessage: StateFlow&lt;String?&gt; = _errorMessage.asStateFlow()&#10;&#10;    // ID da instituição logada (carregado do AuthDataStore)&#10;    private val _instituicaoId = MutableStateFlow&lt;Int?&gt;(null)&#10;    val instituicaoId: StateFlow&lt;Int?&gt; = _instituicaoId.asStateFlow()&#10;&#10;    // Flag para controlar se já carregou conversas&#10;    private var conversasCarregadas = false&#10;&#10;    init {&#10;        // Carrega o ID da instituição ao inicializar o ViewModel&#10;        viewModelScope.launch {&#10;            val instituicao = authDataStore.loadInstituicao()&#10;            _instituicaoId.value = instituicao?.instituicao_id&#10;            Log.d(&quot;ChatViewModel&quot;, &quot;Instituição logada: ID=${instituicao?.instituicao_id}, Nome=${instituicao?.nome}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carrega conversas apenas na primeira vez que entra na tela&#10;     */&#10;    fun carregarConversas(forcarRecarregar: Boolean = false) {&#10;        if (conversasCarregadas &amp;&amp; !forcarRecarregar) {&#10;            Log.d(&quot;ChatViewModel&quot;, &quot;Conversas já carregadas, pulando requisição&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            try {&#10;                // Aguarda o ID da instituição estar disponível&#10;                val instId = _instituicaoId.value&#10;                if (instId == null) {&#10;                    _errorMessage.value = &quot;Usuário não está logado&quot;&#10;                    Log.e(&quot;ChatViewModel&quot;, &quot;Instituição não está logada&quot;)&#10;                    _isLoading.value = false&#10;                    return@launch&#10;                }&#10;&#10;                val response = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {&#10;                    instituicaoService.buscarPorId(instId).execute()&#10;                }&#10;&#10;                if (response.isSuccessful) {&#10;                    val instituicao = response.body()?.instituicao&#10;                    val conversasInstituicao = instituicao?.conversas ?: emptyList()&#10;&#10;                    _conversas.value = conversasInstituicao.map { conversa -&gt;&#10;                        ConversaUI(&#10;                            id = conversa.id_conversa,&#10;                            nome = conversa.outro_participante.nome,&#10;                            ultimaMensagem = conversa.ultima_mensagem?.descricao ?: &quot;Sem mensagens&quot;,&#10;                            hora = formatarHora(conversa.ultima_mensagem?.data_envio),&#10;                            imagem = com.example.oportunyfam_mobile_ong.R.drawable.perfil,&#10;                            online = false,&#10;                            mensagensNaoLidas = 0,&#10;                            pessoaId = conversa.outro_participante.id&#10;                        )&#10;                    }&#10;                    conversasCarregadas = true&#10;                    Log.d(&quot;ChatViewModel&quot;, &quot;Conversas carregadas pela primeira vez: ${_conversas.value.size}&quot;)&#10;                } else {&#10;                    _errorMessage.value = &quot;Erro ao carregar conversas: ${response.message()}&quot;&#10;                    Log.e(&quot;ChatViewModel&quot;, &quot;Erro: ${response.errorBody()?.string()}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Erro ao conectar: ${e.message}&quot;&#10;                Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao carregar conversas&quot;, e)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inicia escuta em tempo real do Firebase para uma conversa&#10;     * Primeiro carrega do backend, depois mantém sincronização em tempo real&#10;     */&#10;    fun iniciarEscutaMensagens(conversaId: Int) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;&#10;                // Primeiro, carrega mensagens do backend&#10;                val response = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {&#10;                    mensagemService.listarPorConversa(conversaId)&#10;                }&#10;&#10;                if (response.isSuccessful) {&#10;                    val mensagensBackend = response.body()?.mensagens ?: emptyList()&#10;                    _mensagens.value = mensagensBackend&#10;                    Log.d(&quot;ChatViewModel&quot;, &quot;Mensagens carregadas do backend: ${mensagensBackend.size}&quot;)&#10;&#10;                    // Sincroniza com Firebase em background (não bloqueia a UI)&#10;                    launch(kotlinx.coroutines.Dispatchers.IO) {&#10;                        try {&#10;                            firebaseMensagemService.sincronizarMensagens(conversaId, mensagensBackend)&#10;                            Log.d(&quot;ChatViewModel&quot;, &quot;Mensagens sincronizadas com Firebase: ${mensagensBackend.size}&quot;)&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao sincronizar mensagens&quot;, e)&#10;                        }&#10;                    }&#10;                } else {&#10;                    _errorMessage.value = &quot;Erro ao carregar mensagens&quot;&#10;                    Log.e(&quot;ChatViewModel&quot;, &quot;Erro: ${response.errorBody()?.string()}&quot;)&#10;                }&#10;&#10;                _isLoading.value = false&#10;&#10;                // Agora escuta mudanças em tempo real do Firebase&#10;                firebaseMensagemService.observarMensagens(conversaId).collect { mensagensAtualizadas -&gt;&#10;                    if (mensagensAtualizadas.isNotEmpty()) {&#10;                        _mensagens.value = mensagensAtualizadas&#10;                        Log.d(&quot;ChatViewModel&quot;, &quot; Mensagens atualizadas EM TEMPO REAL: ${mensagensAtualizadas.size}&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Erro ao carregar mensagens: ${e.message}&quot;&#10;                Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao iniciar escuta de mensagens&quot;, e)&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Envia mensagem: primeiro salva no backend, depois no Firebase&#10;     * O Firebase notifica todos os listeners automaticamente&#10;     */&#10;    fun enviarMensagem(conversaId: Int, pessoaId: Int, texto: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // 1. Envia para o backend (fonte da verdade)&#10;                val request = MensagemRequest(&#10;                    id_conversa = conversaId,&#10;                    id_pessoa = pessoaId,&#10;                    descricao = texto&#10;                )&#10;                val response = mensagemService.criar(request)&#10;&#10;                if (response.isSuccessful) {&#10;                    val mensagemCriada = response.body()?.mensagem&#10;&#10;                    if (mensagemCriada != null) {&#10;                        // 2. Envia para o Firebase (notifica em tempo real)&#10;                        firebaseMensagemService.enviarMensagem(mensagemCriada)&#10;                        Log.d(&quot;ChatViewModel&quot;, &quot;✅ Mensagem enviada: ${mensagemCriada.id}&quot;)&#10;                    }&#10;                } else {&#10;                    _errorMessage.value = &quot;Erro ao enviar mensagem&quot;&#10;                    Log.e(&quot;ChatViewModel&quot;, &quot;Erro: ${response.errorBody()?.string()}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Erro ao enviar: ${e.message}&quot;&#10;                Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao enviar mensagem&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun limparErro() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    private fun formatarHora(dataHora: String?): String {&#10;        if (dataHora == null) return &quot;Agora&quot;&#10;        return try {&#10;            // Formato: &quot;2025-11-06 12:49:09.000000&quot;&#10;            val partes = dataHora.split(&quot; &quot;)&#10;            if (partes.size &gt; 1) {&#10;                val hora = partes[1].substring(0, 5)&#10;                hora&#10;            } else {&#10;                &quot;Agora&quot;&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;ChatViewModel&quot;, &quot;Erro ao formatar hora: $dataHora&quot;, e)&#10;            &quot;Agora&quot;&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>